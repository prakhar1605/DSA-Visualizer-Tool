<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Visualizer - Working Version</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .description {
            color: #7f8c8d;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .main-content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .visualization {
            flex: 2;
            min-width: 300px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            min-height: 500px;
        }
        
        .algorithm-selector {
            margin-bottom: 20px;
        }
        
        .algorithm-selector h3 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .algorithm-buttons {
            display: flex;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        button:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        button.active {
            background: #2c3e50;
        }
        
        .control-group {
            margin-bottom: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        
        .control-group h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        
        .step-controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .step-controls button {
            flex: 1;
        }
        
        #prevStep {
            background: #e74c3c;
        }
        
        #prevStep:hover {
            background: #c0392b;
        }
        
        #nextStep {
            background: #2ecc71;
        }
        
        #nextStep:hover {
            background: #27ae60;
        }
        
        #reset {
            background: #f39c12;
        }
        
        #reset:hover {
            background: #d35400;
        }
        
        .explanation {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4fc;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        
        .explanation h4 {
            margin-bottom: 10px;
            color: #2c3e50;
        }
        
        .canvas {
            width: 100%;
            height: 400px;
            border: 1px solid #eee;
            border-radius: 5px;
            position: relative;
            overflow: auto;
            background: #fafafa;
        }
        
        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.5s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .node.visited {
            background: #2ecc71;
        }
        
        .node.current {
            background: #e74c3c;
            transform: scale(1.2);
        }
        
        .edge {
            position: absolute;
            height: 3px;
            background: #7f8c8d;
            transform-origin: 0 0;
            z-index: 1;
        }
        
        .dijkstra-node {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.5s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 10;
        }
        
        .dijkstra-node .label {
            font-size: 18px;
        }
        
        .dijkstra-node .distance {
            font-size: 14px;
            margin-top: 2px;
        }
        
        .dijkstra-node.visited {
            background: #2ecc71;
        }
        
        .dijkstra-node.current {
            background: #e74c3c;
            transform: scale(1.2);
        }
        
        .dijkstra-edge {
            position: absolute;
            height: 3px;
            background: #7f8c8d;
            transform-origin: 0 0;
            z-index: 1;
        }
        
        .weight {
            position: absolute;
            background: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 14px;
            border: 1px solid #ddd;
            z-index: 5;
        }
        
        .traversal-order {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .order-node {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: #3498db;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .order-node.current {
            background: #e74c3c;
            transform: scale(1.2);
        }
        
        .order-node.visited {
            background: #2ecc71;
        }
        
        .status {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        
        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }
            
            .canvas {
                height: 300px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DSA Visualizer - Working Version</h1>
            <p class="description">Visualize Binary Tree Traversal and Dijkstra's Algorithm with step-by-step animations</p>
        </header>
        
        <div class="main-content">
            <div class="controls">
                <div class="algorithm-selector">
                    <h3>Select Algorithm</h3>
                    <div class="algorithm-buttons">
                        <button id="btnTree" class="active">Binary Tree</button>
                        <button id="btnDijkstra">Dijkstra's</button>
                    </div>
                </div>
                
                <div id="treeControls">
                    <div class="control-group">
                        <h4>Tree Type</h4>
                        <select id="treeType">
                            <option value="balanced">Balanced Tree</option>
                            <option value="unbalanced">Unbalanced Tree</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h4>Traversal Type</h4>
                        <select id="traversalType">
                            <option value="inorder">Inorder (Left, Root, Right)</option>
                            <option value="preorder">Preorder (Root, Left, Right)</option>
                            <option value="postorder">Postorder (Left, Right, Root)</option>
                        </select>
                    </div>
                    
                    <button id="generateTree">Generate Tree & Start</button>
                </div>
                
                <div id="dijkstraControls" style="display: none;">
                    <div class="control-group">
                        <h4>Graph Type</h4>
                        <select id="graphType">
                            <option value="simple">Simple Graph</option>
                            <option value="complex">Complex Graph</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <h4>Start Node</h4>
                        <select id="startNode">
                            <option value="A">A</option>
                            <option value="B">B</option>
                            <option value="C">C</option>
                            <option value="D">D</option>
                        </select>
                    </div>
                    
                    <button id="generateGraph">Generate Graph & Start</button>
                </div>
                
                <div class="step-controls">
                    <button id="prevStep">Previous Step</button>
                    <button id="nextStep">Next Step</button>
                    <button id="reset">Reset</button>
                </div>
                
                <div class="explanation">
                    <h4>Algorithm Explanation</h4>
                    <p id="explanationText">Select an algorithm and click generate to start visualization.</p>
                </div>
                
                <div class="traversal-order" id="traversalOrder"></div>
                <div class="status" id="status">Ready to visualize! Click Generate to start.</div>
            </div>
            
            <div class="visualization">
                <h3>Visualization</h3>
                <div class="canvas" id="canvas">
                    <!-- Visualization will be rendered here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Simple and working DSA Visualizer
        document.addEventListener('DOMContentLoaded', function() {
            // DOM elements
            const btnTree = document.getElementById('btnTree');
            const btnDijkstra = document.getElementById('btnDijkstra');
            const treeControls = document.getElementById('treeControls');
            const dijkstraControls = document.getElementById('dijkstraControls');
            const generateTree = document.getElementById('generateTree');
            const generateGraph = document.getElementById('generateGraph');
            const prevStep = document.getElementById('prevStep');
            const nextStep = document.getElementById('nextStep');
            const reset = document.getElementById('reset');
            const explanationText = document.getElementById('explanationText');
            const canvas = document.getElementById('canvas');
            const traversalOrderContainer = document.getElementById('traversalOrder');
            const status = document.getElementById('status');
            
            // State variables
            let currentAlgorithm = 'tree';
            let currentStep = 0;
            let steps = [];
            let traversalOrder = [];
            
            // Event listeners
            btnTree.addEventListener('click', function() {
                currentAlgorithm = 'tree';
                btnTree.classList.add('active');
                btnDijkstra.classList.remove('active');
                treeControls.style.display = 'block';
                dijkstraControls.style.display = 'none';
                resetVisualization();
                status.textContent = 'Binary Tree selected. Click Generate to start.';
            });
            
            btnDijkstra.addEventListener('click', function() {
                currentAlgorithm = 'dijkstra';
                btnDijkstra.classList.add('active');
                btnTree.classList.remove('active');
                dijkstraControls.style.display = 'block';
                treeControls.style.display = 'none';
                resetVisualization();
                status.textContent = "Dijkstra's Algorithm selected. Click Generate to start.";
            });
            
            generateTree.addEventListener('click', function() {
                generateTreeVisualization();
            });
            
            generateGraph.addEventListener('click', function() {
                generateGraphVisualization();
            });
            
            prevStep.addEventListener('click', function() {
                if (currentStep > 0) {
                    currentStep--;
                    updateVisualization();
                    status.textContent = `Step ${currentStep + 1} of ${steps.length}`;
                }
            });
            
            nextStep.addEventListener('click', function() {
                if (currentStep < steps.length - 1) {
                    currentStep++;
                    updateVisualization();
                    status.textContent = `Step ${currentStep + 1} of ${steps.length}`;
                } else {
                    status.textContent = 'Algorithm completed! Click Reset to start over.';
                }
            });
            
            reset.addEventListener('click', resetVisualization);
            
            // Tree visualization functions
            function generateTreeVisualization() {
                resetVisualization();
                status.textContent = 'Generating tree visualization...';
                
                // Generate tree based on selection
                const treeType = document.getElementById('treeType').value;
                const traversalType = document.getElementById('traversalType').value;
                
                let tree;
                if (treeType === 'balanced') {
                    tree = {
                        value: 1,
                        left: {
                            value: 2,
                            left: { value: 4, left: null, right: null },
                            right: { value: 5, left: null, right: null }
                        },
                        right: {
                            value: 3,
                            left: { value: 6, left: null, right: null },
                            right: { value: 7, left: null, right: null }
                        }
                    };
                } else {
                    tree = {
                        value: 1,
                        left: {
                            value: 2,
                            left: { value: 4, left: null, right: null },
                            right: null
                        },
                        right: {
                            value: 3,
                            left: null,
                            right: {
                                value: 5,
                                left: null,
                                right: { value: 6, left: null, right: null }
                            }
                        }
                    };
                }
                
                // Generate traversal steps
                steps = [];
                traversalOrder = [];
                
                if (traversalType === 'inorder') {
                    inorderTraversal(tree);
                } else if (traversalType === 'preorder') {
                    preorderTraversal(tree);
                } else {
                    postorderTraversal(tree);
                }
                
                // Render tree
                renderTree(tree);
                
                // Enable controls
                prevStep.disabled = false;
                nextStep.disabled = false;
                reset.disabled = false;
                
                // Update explanation
                explanationText.textContent = `Binary Tree ${traversalType} traversal. Click Next Step to see the algorithm in action.`;
                
                // Show first step
                currentStep = 0;
                updateVisualization();
                status.textContent = `Tree generated! Step ${currentStep + 1} of ${steps.length}. Use Next Step to continue.`;
            }
            
            function inorderTraversal(node) {
                if (!node) return;
                
                inorderTraversal(node.left);
                steps.push({
                    type: 'visit',
                    node: node.value,
                    explanation: `Visiting node ${node.value} (inorder traversal)`
                });
                traversalOrder.push(node.value);
                inorderTraversal(node.right);
            }
            
            function preorderTraversal(node) {
                if (!node) return;
                
                steps.push({
                    type: 'visit',
                    node: node.value,
                    explanation: `Visiting node ${node.value} (preorder traversal)`
                });
                traversalOrder.push(node.value);
                preorderTraversal(node.left);
                preorderTraversal(node.right);
            }
            
            function postorderTraversal(node) {
                if (!node) return;
                
                postorderTraversal(node.left);
                postorderTraversal(node.right);
                steps.push({
                    type: 'visit',
                    node: node.value,
                    explanation: `Visiting node ${node.value} (postorder traversal)`
                });
                traversalOrder.push(node.value);
            }
            
            function renderTree(tree) {
                canvas.innerHTML = '';
                
                // Calculate node positions
                const positions = calculateTreePositions(tree);
                
                // Draw edges
                drawTreeEdges(tree, positions);
                
                // Draw nodes
                for (const [nodeId, pos] of Object.entries(positions)) {
                    const nodeElement = document.createElement('div');
                    nodeElement.className = 'node';
                    nodeElement.id = `node-${nodeId}`;
                    nodeElement.textContent = nodeId;
                    nodeElement.style.left = `${pos.x}px`;
                    nodeElement.style.top = `${pos.y}px`;
                    canvas.appendChild(nodeElement);
                }
            }
            
            function calculateTreePositions(tree) {
                const positions = {};
                const levelHeight = 80;
                const nodeSpacing = 70;
                
                function calculate(node, level, offset) {
                    if (!node) return offset;
                    
                    const leftOffset = calculate(node.left, level + 1, offset);
                    const x = leftOffset * nodeSpacing + 50;
                    const y = level * levelHeight + 50;
                    
                    positions[node.value] = { x, y };
                    
                    const rightOffset = calculate(node.right, level + 1, leftOffset + 1);
                    return rightOffset;
                }
                
                calculate(tree, 0, 0);
                return positions;
            }
            
            function drawTreeEdges(tree, positions) {
                function draw(node) {
                    if (!node) return;
                    
                    if (node.left) {
                        drawEdge(positions[node.value], positions[node.left.value]);
                        draw(node.left);
                    }
                    
                    if (node.right) {
                        drawEdge(positions[node.value], positions[node.right.value]);
                        draw(node.right);
                    }
                }
                
                draw(tree);
            }
            
            function drawEdge(from, to) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                const edge = document.createElement('div');
                edge.className = 'edge';
                edge.style.width = `${length}px`;
                edge.style.left = `${from.x}px`;
                edge.style.top = `${from.y}px`;
                edge.style.transform = `rotate(${angle}deg)`;
                canvas.appendChild(edge);
            }
            
            // Dijkstra visualization functions
            function generateGraphVisualization() {
                resetVisualization();
                status.textContent = 'Generating graph visualization...';
                
                // Generate graph based on selection
                const graphType = document.getElementById('graphType').value;
                const startNode = document.getElementById('startNode').value;
                
                let graph;
                if (graphType === 'simple') {
                    graph = {
                        nodes: [
                            { id: 'A', x: 100, y: 100 },
                            { id: 'B', x: 250, y: 100 },
                            { id: 'C', x: 100, y: 250 },
                            { id: 'D', x: 250, y: 250 }
                        ],
                        edges: [
                            { from: 'A', to: 'B', weight: 4 },
                            { from: 'A', to: 'C', weight: 2 },
                            { from: 'B', to: 'D', weight: 5 },
                            { from: 'C', to: 'D', weight: 1 }
                        ]
                    };
                } else {
                    graph = {
                        nodes: [
                            { id: 'A', x: 100, y: 100 },
                            { id: 'B', x: 250, y: 50 },
                            { id: 'C', x: 400, y: 100 },
                            { id: 'D', x: 250, y: 200 },
                            { id: 'E', x: 400, y: 250 }
                        ],
                        edges: [
                            { from: 'A', to: 'B', weight: 3 },
                            { from: 'A', to: 'D', weight: 7 },
                            { from: 'B', to: 'C', weight: 2 },
                            { from: 'B', to: 'D', weight: 1 },
                            { from: 'C', to: 'E', weight: 5 },
                            { from: 'D', to: 'C', weight: 2 },
                            { from: 'D', to: 'E', weight: 3 }
                        ]
                    };
                }
                
                // Generate Dijkstra steps
                steps = generateDijkstraSteps(graph, startNode);
                
                // Render graph
                renderGraph(graph);
                
                // Enable controls
                prevStep.disabled = false;
                nextStep.disabled = false;
                reset.disabled = false;
                
                // Update explanation
                explanationText.textContent = "Dijkstra's Algorithm: Finding shortest paths. Click Next Step to see the algorithm in action.";
                
                // Show first step
                currentStep = 0;
                updateVisualization();
                status.textContent = `Graph generated! Step ${currentStep + 1} of ${steps.length}. Use Next Step to continue.`;
            }
            
            function generateDijkstraSteps(graph, start) {
                const steps = [];
                const distances = {};
                const visited = {};
                
                // Initialize
                graph.nodes.forEach(node => {
                    distances[node.id] = (node.id === start) ? 0 : Infinity;
                    visited[node.id] = false;
                });
                
                steps.push({
                    type: 'init',
                    distances: {...distances},
                    current: start,
                    explanation: `Initializing distances. Start node ${start} has distance 0.`
                });
                
                // Main algorithm
                for (let i = 0; i < graph.nodes.length; i++) {
                    // Find unvisited node with smallest distance
                    let current = null;
                    for (const node of graph.nodes) {
                        if (!visited[node.id] && (current === null || distances[node.id] < distances[current])) {
                            current = node.id;
                        }
                    }
                    
                    if (current === null || distances[current] === Infinity) break;
                    
                    visited[current] = true;
                    
                    steps.push({
                        type: 'visit',
                        current: current,
                        distances: {...distances},
                        explanation: `Visiting node ${current} with distance ${distances[current]}.`
                    });
                    
                    // Update neighbors
                    for (const edge of graph.edges) {
                        if (edge.from === current && !visited[edge.to]) {
                            const newDist = distances[current] + edge.weight;
                            if (newDist < distances[edge.to]) {
                                distances[edge.to] = newDist;
                                
                                steps.push({
                                    type: 'update',
                                    current: current,
                                    neighbor: edge.to,
                                    newDistance: newDist,
                                    edge: edge,
                                    distances: {...distances},
                                    explanation: `Updating distance to ${edge.to} via ${current}. New distance: ${newDist}.`
                                });
                            }
                        }
                    }
                }
                
                steps.push({
                    type: 'complete',
                    distances: {...distances},
                    explanation: `Algorithm complete. Shortest paths from ${start} calculated.`
                });
                
                return steps;
            }
            
            function renderGraph(graph) {
                canvas.innerHTML = '';
                
                // Draw edges
                graph.edges.forEach(edge => {
                    const fromNode = graph.nodes.find(n => n.id === edge.from);
                    const toNode = graph.nodes.find(n => n.id === edge.to);
                    
                    if (fromNode && toNode) {
                        drawGraphEdge(fromNode, toNode, edge.weight);
                    }
                });
                
                // Draw nodes
                graph.nodes.forEach(node => {
                    const nodeElement = document.createElement('div');
                    nodeElement.className = 'dijkstra-node';
                    nodeElement.id = `node-${node.id}`;
                    nodeElement.innerHTML = `
                        <div class="label">${node.id}</div>
                        <div class="distance" id="dist-${node.id}">∞</div>
                    `;
                    nodeElement.style.left = `${node.x}px`;
                    nodeElement.style.top = `${node.y}px`;
                    canvas.appendChild(nodeElement);
                });
            }
            
            function drawGraphEdge(from, to, weight) {
                const dx = to.x - from.x;
                const dy = to.y - from.y;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                const edge = document.createElement('div');
                edge.className = 'dijkstra-edge';
                edge.id = `edge-${from.id}-${to.id}`;
                edge.style.width = `${length}px`;
                edge.style.left = `${from.x}px`;
                edge.style.top = `${from.y}px`;
                edge.style.transform = `rotate(${angle}deg)`;
                canvas.appendChild(edge);
                
                // Add weight label
                const weightEl = document.createElement('div');
                weightEl.className = 'weight';
                weightEl.textContent = weight;
                weightEl.style.left = `${from.x + dx/2 - 10}px`;
                weightEl.style.top = `${from.y + dy/2 - 10}px`;
                canvas.appendChild(weightEl);
            }
            
            // Update visualization based on current step
            function updateVisualization() {
                if (steps.length === 0) return;
                
                const step = steps[currentStep];
                explanationText.textContent = step.explanation;
                
                if (currentAlgorithm === 'tree') {
                    updateTreeVisualization(step);
                } else {
                    updateGraphVisualization(step);
                }
                
                updateTraversalOrder();
            }
            
            function updateTreeVisualization(step) {
                // Reset all nodes
                document.querySelectorAll('.node').forEach(node => {
                    node.classList.remove('visited', 'current');
                });
                
                // Mark visited nodes
                for (let i = 0; i < currentStep; i++) {
                    const visitedNode = document.getElementById(`node-${steps[i].node}`);
                    if (visitedNode) {
                        visitedNode.classList.add('visited');
                    }
                }
                
                // Highlight current node
                const currentNode = document.getElementById(`node-${step.node}`);
                if (currentNode) {
                    currentNode.classList.add('current');
                }
            }
            
            function updateGraphVisualization(step) {
                // Reset all nodes and edges
                document.querySelectorAll('.dijkstra-node').forEach(node => {
                    node.classList.remove('visited', 'current');
                });
                
                document.querySelectorAll('.dijkstra-edge').forEach(edge => {
                    edge.classList.remove('highlighted');
                });
                
                // Update distances
                if (step.distances) {
                    for (const [nodeId, dist] of Object.entries(step.distances)) {
                        const distEl = document.getElementById(`dist-${nodeId}`);
                        if (distEl) {
                            distEl.textContent = dist === Infinity ? '∞' : dist;
                        }
                    }
                }
                
                // Mark visited nodes
                for (let i = 0; i <= currentStep; i++) {
                    const s = steps[i];
                    if (s.type === 'visit') {
                        const visitedNode = document.getElementById(`node-${s.current}`);
                        if (visitedNode) {
                            visitedNode.classList.add('visited');
                        }
                    }
                    
                    // Highlight updated edges
                    if (s.type === 'update') {
                        const edge = document.getElementById(`edge-${s.current}-${s.neighbor}`);
                        if (edge) {
                            edge.classList.add('highlighted');
                        }
                    }
                }
                
                // Highlight current node
                if (step.current) {
                    const currentNode = document.getElementById(`node-${step.current}`);
                    if (currentNode) {
                        currentNode.classList.add('current');
                    }
                }
            }
            
            function updateTraversalOrder() {
                traversalOrderContainer.innerHTML = '';
                
                if (currentAlgorithm === 'tree' && traversalOrder.length > 0) {
                    traversalOrder.forEach((value, index) => {
                        const node = document.createElement('div');
                        node.className = 'order-node';
                        if (index < currentStep) {
                            node.classList.add('visited');
                        } else if (index === currentStep) {
                            node.classList.add('current');
                        }
                        node.textContent = value;
                        traversalOrderContainer.appendChild(node);
                    });
                }
            }
            
            function resetVisualization() {
                currentStep = 0;
                steps = [];
                traversalOrder = [];
                canvas.innerHTML = '';
                traversalOrderContainer.innerHTML = '';
                explanationText.textContent = 'Select an algorithm and click generate to start visualization.';
                prevStep.disabled = true;
                nextStep.disabled = true;
                reset.disabled = true;
                status.textContent = 'Visualization reset. Ready to generate new visualization.';
            }
            
            // Initialize
            resetVisualization();
        });
    </script>
</body>
</html>
