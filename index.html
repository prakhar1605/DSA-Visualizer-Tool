<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Visualizer Tool</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style type="text/tailwindcss">
        /* Custom styles for the app, complementing Tailwind */
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #4cc9f0;
            --warning: #f72585;
            --gray: #6c757d;
        }

        @layer base {
            body {
                @apply bg-gradient-to-br from-[#1a1a2e] to-[#16213e] text-light min-h-screen p-5 overflow-x-hidden;
                font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            }
            .container {
                @apply max-w-7xl mx-auto relative pb-24; /* Increased padding for the footer */
            }
            /* Custom CSS for gradient text */
            .gradient-text {
                background: linear-gradient(90deg, var(--accent), var(--success));
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                text-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }
            /* Custom CSS for pulse animation */
            .author-highlight {
                background: linear-gradient(90deg, #ff9f1c, #ff4d6d);
                -webkit-background-clip: text;
                background-clip: text;
                color: transparent;
                font-weight: bold;
                padding: 3px 8px;
                border-radius: 5px;
                animation: pulse 2s infinite;
            }
            @keyframes pulse {
                0% { text-shadow: 0 0 5px rgba(255, 159, 28, 0.5); }
                50% { text-shadow: 0 0 20px rgba(255, 77, 109, 0.8); }
                100% { text-shadow: 0 0 5px rgba(255, 159, 28, 0.5); }
            }
            /* Custom CSS for specific element styles */
            .signature {
                @apply inline-flex items-center gap-2 mt-1 p-2 px-5 bg-[rgba(255,255,255,0.1)] rounded-full border border-[rgba(255,255,255,0.15)];
            }
            .linkedin-link {
                @apply block mt-2 text-accent no-underline transition-colors duration-300;
            }
            .linkedin-link:hover {
                @apply text-success underline;
            }
            .watermark {
                @apply absolute bottom-16 right-5 opacity-10 text-[10rem] font-bold -rotate-12 text-success pointer-events-none z-0;
            }
            /* Styling for the visualization nodes and edges */
            .node {
                @apply absolute w-12 h-12 rounded-full bg-primary flex items-center justify-center text-white font-bold shadow-lg cursor-pointer z-10 transition-all duration-300;
            }
            .node:hover {
                @apply transform scale-110 bg-success;
            }
            .edge {
                @apply absolute h-1 bg-accent transform origin-top-left z-5;
            }
            .edge-weight {
                @apply absolute bg-[rgba(30,30,50,0.9)] text-light py-0.5 px-2 rounded-xl text-sm z-7;
            }
            /* Highlighting colors */
            .current { background: #f72585 !important; }
            .visited { background: #4cc9f0 !important; }
            .path { background: #2ec4b6 !important; }
            .heap { background: #ff9f1c !important; }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- The watermark is now positioned correctly to avoid overlap -->
        <div class="watermark hidden md:block">DSA</div>
        
        <header class="text-center py-5 mb-8">
            <h1 class="text-4xl md:text-5xl font-extrabold mb-2 gradient-text">
                <i class="fas fa-project-diagram mr-3"></i> Data Structures & Algorithms Visualizer
            </h1>
            <p class="subtitle text-accent max-w-3xl mx-auto leading-relaxed">
                An interactive visualization tool that demonstrates complex algorithms through intuitive animations and step-by-step explanations.
            </p>
        </header>
        
        <div class="tabs flex justify-center flex-wrap gap-3 mb-8">
            <button class="tab-btn active" data-tab="tree">
                <i class="fas fa-tree"></i> Binary Tree Traversal
            </button>
            <button class="tab-btn" data-tab="sorting">
                <i class="fas fa-sort-amount-down"></i> Sorting Algorithms
            </button>
            <button class="tab-btn" data-tab="dijkstra">
                <i class="fas fa-route"></i> Dijkstra's Algorithm
            </button>
            <button class="tab-btn" data-tab="recursion">
                <i class="fas fa-sitemap"></i> Recursion Stack
            </button>
        </div>
        
        <div class="controls flex flex-wrap justify-center gap-4 bg-[rgba(40,40,60,0.8)] rounded-xl p-5 mb-8 items-center">
            <div class="control-group flex items-center gap-2">
                <label for="algorithm" class="text-accent font-medium"><i class="fas fa-code mr-1"></i> Algorithm:</label>
                <select id="algorithm" class="py-2 px-3 rounded-lg border border-[rgba(255,255,255,0.1)] bg-[rgba(255,255,255,0.1)] text-light">
                    <option value="preorder">Preorder Traversal</option>
                    <option value="inorder">Inorder Traversal</option>
                    <option value="postorder">Postorder Traversal</option>
                </select>
            </div>
            
            <div class="control-group flex items-center gap-2">
                <label for="speed" class="text-accent font-medium"><i class="fas fa-tachometer-alt mr-1"></i> Speed:</label>
                <input type="range" id="speed" min="1" max="10" value="5" class="w-full">
            </div>
            
            <button id="generate" class="btn btn-primary">
                <i class="fas fa-sync-alt"></i> Generate New
            </button>
            <button id="start" class="btn btn-primary">
                <i class="fas fa-play"></i> Start Visualization
            </button>
            <button id="pause" class="btn btn-primary">
                <i class="fas fa-pause"></i> Pause
            </button>
            <button id="reset" class="btn btn-primary">
                <i class="fas fa-redo"></i> Reset
            </button>
        </div>
        
        <main class="visualization-container">
            <h2 class="visualization-title">
                <i class="fas fa-tree mr-2"></i> Binary Tree Traversal Visualization
            </h2>
            
            <div class="canvas-container flex justify-center items-center min-h-[400px] relative">
                <div class="tree-container" id="treeCanvas"></div>
            </div>
            
            <div class="explanation">
                <h3><i class="fas fa-lightbulb mr-2"></i> Algorithm Explanation</h3>
                <p><strong>Tree traversal</strong> refers to the process of visiting each node in a tree data structure exactly once.</p>
                
                <!-- Code snippets will be dynamically inserted here by JavaScript -->
            </div>
        </main>
        
        <div class="legend flex flex-wrap justify-center gap-5 mt-5">
            <div class="legend-item flex items-center gap-2">
                <div class="w-5 h-5 rounded bg-primary"></div>
                <span>Normal Node</span>
            </div>
            <div class="legend-item flex items-center gap-2">
                <div class="w-5 h-5 rounded current"></div>
                <span>Current Node</span>
            </div>
            <div class="legend-item flex items-center gap-2">
                <div class="w-5 h-5 rounded visited"></div>
                <span>Visited Node</span>
            </div>
            <div class="legend-item flex items-center gap-2">
                <div class="w-5 h-5 rounded path"></div>
                <span>Path Node</span>
            </div>
            <div class="legend-item flex items-center gap-2">
                <div class="w-5 h-5 rounded heap"></div>
                <span>Heap Node</span>
            </div>
        </div>
        
        <!-- The footer is now at the end of the document flow -->
        <footer class="text-center py-5 mt-10 text-[rgba(255,255,255,0.7)] text-lg z-50">
            <div>
                <p>Designed and developed with <i class="fas fa-heart text-[#ff4d6d]"></i></p>
                <div class="signature">
                    <i class="fas fa-user"></i>
                    <span>Made by <span class="author-highlight">Prakhar</span> in May 2025</span>
                </div>
                <a href="https://www.linkedin.com/in/prakhar-pandey-56267a2a2/" target="_blank" class="linkedin-link">
                    <i class="fab fa-linkedin"></i> Connect with me on LinkedIn
                </a>
            </div>
        </footer>
    </div>

    <!-- JavaScript logic is now at the end of the body for better performance -->
    <script>
        // Tab switching functionality
        const tabBtns = document.querySelectorAll('.tab-btn');
        tabBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                tabBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                const tab = btn.getAttribute('data-tab');
                updateVisualization(tab);
            });
        });
        
        function updateVisualization(tab) {
            const title = document.querySelector('.visualization-title');
            const explanation = document.querySelector('.explanation');
            
            switch(tab) {
                case 'tree':
                    title.innerHTML = '<i class="fas fa-tree mr-2"></i> Binary Tree Traversal Visualization';
                    explanation.innerHTML = `
                        <h3><i class="fas fa-lightbulb mr-2"></i> Algorithm Explanation</h3>
                        <p><strong>Tree traversal</strong> refers to the process of visiting each node in a tree data structure exactly once. The three common traversal methods are:</p>
                        
                        <div class="code-snippet">
                            // Preorder: Root → Left → Right<br>
                            function preorder(node) {<br>
                            &nbsp;&nbsp;if (node == null) return;<br>
                            &nbsp;&nbsp;visit(node);<br>
                            &nbsp;&nbsp;preorder(node.left);<br>
                            &nbsp;&nbsp;preorder(node.right);<br>
                            }
                        </div>
                        
                        <div class="code-snippet">
                            // Inorder: Left → Root → Right<br>
                            function inorder(node) {<br>
                            &nbsp;&nbsp;if (node == null) return;<br>
                            &nbsp;&nbsp;inorder(node.left);<br>
                            &nbsp;&nbsp;visit(node);<br>
                            &nbsp;&nbsp;inorder(node.right);<br>
                            }
                        </div>
                        
                        <div class="code-snippet">
                            // Postorder: Left → Right → Root<br>
                            function postorder(node) {<br>
                            &nbsp;&nbsp;if (node == null) return;<br>
                            &nbsp;&nbsp;postorder(node.left);<br>
                            &nbsp;&nbsp;postorder(node.right);<br>
                            &nbsp;&nbsp;visit(node);<br>
                            }
                        </div>
                    `;
                    break;
                    
                case 'sorting':
                    title.innerHTML = '<i class="fas fa-sort-amount-down mr-2"></i> Sorting Algorithms Visualization';
                    explanation.innerHTML = `
                        <h3><i class="fas fa-lightbulb mr-2"></i> Sorting Algorithms Explained</h3>
                        <p><strong>Sorting algorithms</strong> arrange elements of a list in a particular order. Common algorithms include:</p>
                        
                        <p><strong>Bubble Sort:</strong> Repeatedly steps through the list, compares adjacent elements and swaps them if in wrong order.</p>
                        <p><strong>Selection Sort:</strong> Divides input into sorted and unsorted portions, then finds the smallest element in unsorted portion and moves it to sorted portion.</p>
                        <p><strong>Insertion Sort:</strong> Builds the final sorted array one item at a time by comparisons.</p>
                        <p><strong>Merge Sort:</strong> A divide and conquer algorithm that divides input array into two halves, sorts them, and then merges.</p>
                        <p><strong>Quick Sort:</strong> Picks an element as pivot and partitions the array around the pivot.</p>
                    `;
                    break;
                    
                case 'dijkstra':
                    title.innerHTML = '<i class="fas fa-route mr-2"></i> Dijkstra\'s Algorithm Visualization';
                    explanation.innerHTML = `
                        <h3><i class="fas fa-lightbulb mr-2"></i> Dijkstra's Algorithm Explained</h3>
                        <p><strong>Dijkstra's algorithm</strong> finds the shortest path between nodes in a graph with non-negative edge weights.</p>
                        
                        <div class="code-snippet">
                            function dijkstra(graph, start) {<br>
                            &nbsp;&nbsp;let distances = {};<br>
                            &nbsp;&nbsp;let pq = new PriorityQueue();<br>
                            &nbsp;&nbsp;<br>
                            &nbsp;&nbsp;// Initialize distances<br>
                            &nbsp;&nbsp;for (let node in graph) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;distances[node] = Infinity;<br>
                            &nbsp;&nbsp;}<br>
                            &nbsp;&nbsp;distances[start] = 0;<br>
                            &nbsp;&nbsp;pq.enqueue(start, 0);<br>
                            &nbsp;&nbsp;<br>
                            &nbsp;&nbsp;while (!pq.isEmpty()) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;let minNode = pq.dequeue();<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;let currNode = minNode.element;<br>
                            &nbsp;&nbsp;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;for (let neighbor in graph[currNode]) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let alt = distances[currNode] + graph[currNode][neighbor];<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (alt < distances[neighbor]) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;distances[neighbor] = alt;<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pq.enqueue(neighbor, alt);<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
                            &nbsp;&nbsp;}<br>
                            &nbsp;&nbsp;return distances;<br>
                            }
                        </div>
                    `;
                    break;
                    
                case 'recursion':
                    title.innerHTML = '<i class="fas fa-sitemap mr-2"></i> Recursion Stack Visualization';
                    explanation.innerHTML = `
                        <h3><i class="fas fa-lightbulb mr-2"></i> Understanding Recursion</h3>
                        <p><strong>Recursion</strong> is a programming technique where a function calls itself to solve smaller instances of the same problem.</p>
                        
                        <p>Key components of recursion:</p>
                        <ul>
                            <li><strong>Base Case:</strong> The condition that stops the recursion</li>
                            <li><strong>Recursive Case:</strong> Where the function calls itself</li>
                            <li><strong>Call Stack:</strong> The stack data structure that manages function calls</li>
                        </ul>
                        
                        <div class="code-snippet">
                            function factorial(n) {<br>
                            &nbsp;&nbsp;// Base case<br>
                            &nbsp;&nbsp;if (n === 0) {<br>
                            &nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>
                            &nbsp;&nbsp;}<br>
                            &nbsp;&nbsp;// Recursive case<br>
                            &nbsp;&nbsp;return n * factorial(n - 1);<br>
                            }
                        </div>
                        
                        <p>Each recursive call adds a new frame to the call stack until the base case is reached, then the stack unwinds as each call returns its result.</p>
                    `;
                    break;
            }
        }
        
        // Binary Tree Visualization
        class TreeNode {
            constructor(value) {
                this.value = value;
                this.left = null;
                this.right = null;
            }
        }
        
        class BinaryTree {
            constructor() {
                this.root = null;
            }
            
            createRandomTree() {
                this.root = new TreeNode(Math.floor(Math.random() * 100));
                
                // Helper function to add children
                const addChildren = (node, depth) => {
                    if (depth > 0) {
                        if (Math.random() > 0.3) {
                            node.left = new TreeNode(Math.floor(Math.random() * 100));
                            addChildren(node.left, depth - 1);
                        }
                        if (Math.random() > 0.3) {
                            node.right = new TreeNode(Math.floor(Math.random() * 100));
                            addChildren(node.right, depth - 1);
                        }
                    }
                };
                
                addChildren(this.root, 4);
                return this.root;
            }
            
            preorderTraversal(node, callback) {
                if (node !== null) {
                    callback(node);
                    this.preorderTraversal(node.left, callback);
                    this.preorderTraversal(node.right, callback);
                }
            }
            
            inorderTraversal(node, callback) {
                if (node !== null) {
                    this.inorderTraversal(node.left, callback);
                    callback(node);
                    this.inorderTraversal(node.right, callback);
                }
            }
            
            postorderTraversal(node, callback) {
                if (node !== null) {
                    this.postorderTraversal(node.left, callback);
                    this.postorderTraversal(node.right, callback);
                    callback(node);
                }
            }
        }
        
        // Tree drawing functions
        function drawTree(tree) {
            const container = document.getElementById('treeCanvas');
            container.innerHTML = '';
            
            // Calculate node positions
            const positions = calculateNodePositions(tree.root);
            
            // Draw edges first (so they are behind nodes)
            positions.forEach(node => {
                if (node.parent) {
                    drawEdge(container, node, node.parent);
                }
            });
            
            // Draw nodes
            positions.forEach(node => {
                drawNode(container, node);
            });
        }
        
        function calculateNodePositions(root) {
            if (!root) return [];
            
            const positions = [];
            const queue = [{node: root, x: 500, y: 50, level: 0, parent: null}];
            
            while (queue.length > 0) {
                const {node, x, y, level, parent} = queue.shift();
                positions.push({
                    id: node.value,
                    x,
                    y,
                    level,
                    nodeRef: node,
                    parent: parent ? {x: parent.x, y: parent.y, id: parent.id} : null
                });
                
                if (node.left) {
                    const leftX = x - 200 / (level + 1);
                    queue.push({
                        node: node.left,
                        x: leftX,
                        y: y + 100,
                        level: level + 1,
                        parent: {x, y, id: node.value}
                    });
                }
                
                if (node.right) {
                    const rightX = x + 200 / (level + 1);
                    queue.push({
                        node: node.right,
                        x: rightX,
                        y: y + 100,
                        level: level + 1,
                        parent: {x, y, id: node.value}
                    });
                }
            }
            
            return positions;
        }
        
        function drawNode(container, node) {
            const el = document.createElement('div');
            el.className = 'node';
            el.textContent = node.id;
            el.style.left = `${node.x - 25}px`;
            el.style.top = `${node.y - 25}px`;
            container.appendChild(el);
            return el;
        }
        
        function drawEdge(container, node, parent) {
            // Calculate line between parent and child
            const length = Math.sqrt(Math.pow(node.x - parent.x, 2) + Math.pow(node.y - parent.y, 2));
            const angle = Math.atan2(node.y - parent.y, node.x - parent.x) * 180 / Math.PI;
            
            const edge = document.createElement('div');
            edge.className = 'edge';
            edge.style.width = `${length}px`;
            edge.style.left = `${parent.x}px`;
            edge.style.top = `${parent.y}px`;
            edge.style.transform = `rotate(${angle}deg)`;
            container.appendChild(edge);
        }
        
        // Initialize tree
        const tree = new BinaryTree();
        tree.createRandomTree();
        drawTree(tree);
        
        // Event listeners for buttons
        document.getElementById('generate').addEventListener('click', () => {
            tree.createRandomTree();
            drawTree(tree);
        });
        
        document.getElementById('start').addEventListener('click', () => {
            const algorithm = document.getElementById('algorithm').value;
            visualizeTraversal(algorithm);
        });
        
        // Visualization function
        function visualizeTraversal(algorithm) {
            const nodes = document.querySelectorAll('.node');
            
            // Reset all nodes
            nodes.forEach(node => {
                node.style.background = '';
            });
            
            let traversal = [];
            
            switch(algorithm) {
                case 'preorder':
                    tree.preorderTraversal(tree.root, node => traversal.push(node.value));
                    break;
                case 'inorder':
                    tree.inorderTraversal(tree.root, node => traversal.push(node.value));
                    break;
                case 'postorder':
                    tree.postorderTraversal(tree.root, node => traversal.push(node.value));
                    break;
            }
            
            // Animate traversal
            let i = 0;
            const speed = document.getElementById('speed').value;
            const interval = setInterval(() => {
                if (i >= traversal.length) {
                    clearInterval(interval);
                    return;
                }
                
                // Highlight current node
                nodes.forEach(node => {
                    if (parseInt(node.textContent) === traversal[i]) {
                        node.style.background = '#f72585';
                        node.style.transform = 'scale(1.2)';
                        setTimeout(() => {
                            node.style.transform = 'scale(1)';
                            node.style.background = '#4cc9f0';
                        }, 500);
                    }
                });
                
                i++;
            }, 1000 - (speed * 80));
        }
        
        // Initialize sorting visualization
        function initSortingVisualization() {
            const container = document.querySelector('.sorting-container');
            if (container) {
                container.innerHTML = '';
                
                // Generate random array
                const array = [];
                for (let i = 0; i < 15; i++) {
                    array.push(Math.floor(Math.random() * 250) + 20);
                }
                
                // Create bars
                array.forEach(value => {
                    const bar = document.createElement('div');
                    bar.className = 'bar';
                    bar.style.height = `${value}px`;
                    container.appendChild(bar);
                });
            }
        }
        
        // Initialize on page load
        initSortingVisualization();
    </script>
</body>
</html>
